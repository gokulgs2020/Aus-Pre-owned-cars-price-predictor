import pandas as pd
import numpy as np
import re
import seaborn as sns
import matplotlib.pyplot as plt

df=pd.read_csv("/content/sample_data/Australian Vehicle Prices.csv")

print(df[['Age', 'Kilometres']].dtypes)
df['Age'] = pd.to_numeric(df['Age'], errors='coerce')
df['Kilometres'] = pd.to_numeric(df['Kilometres'], errors='coerce')
df['age_kilometer_interaction'] = (df['Age'] * df['Kilometres']) / 10000
df.head()

df['Seats'] = df['Seats'].astype(str).str.extract('(\d+)').astype(float).astype('Int64', errors='ignore')
df['Seats'] = df['Seats'].fillna(0).astype(int)
df.head()

df['FuelConsumption'] = df['FuelConsumption'].astype(str).str.extract('(\d+\.?\d*)').astype(float)
df['FuelConsumption'] = df['FuelConsumption'].fillna(df['FuelConsumption'].median())
df.head()

print(df['Transmission'].unique())
transmission_mapping = {'Manual': 0, 'Automatic': 1}
df['Transmission'] = df['Transmission'].map(transmission_mapping).fillna(-1).astype(int)
print(df['Transmission'].dtype)
df.head()

print(df['FuelType'].unique())
fuel_type_mapping = {
    'Gasoline': 0,
    'Diesel': 1,
    'Electric': 2,
    'Hybrid': 3,
    'Unleaded': 0, # Assuming Unleaded is a type of Gasoline
    'Premium': 0 # Assuming Premium is a type of Gasoline
}
df['FuelType'] = df['FuelType'].map(fuel_type_mapping).fillna(-1).astype(int)
print(df['FuelType'].dtype)
df.head()

print(df.columns)

print(df['CylindersinEngine'].unique())
df['CylindersinEngine'] = df['CylindersinEngine'].astype(str).str.extract('(\d+)')
df['CylindersinEngine'] = pd.to_numeric(df['CylindersinEngine'].squeeze(), errors='coerce')
df['CylindersinEngine'] = df['CylindersinEngine'].fillna(0).astype(int)
df.head()


import matplotlib.pyplot as plt
import seaborn as sns

# Distribution of Transmission
plt.figure(figsize=(8, 6))
sns.countplot(data=df, x='Transmission')
plt.title('Distribution of Transmission')
plt.xlabel('Transmission')
plt.ylabel('Count')
plt.show()


# Distribution of FuelType
plt.figure(figsize=(10, 6))
sns.countplot(data=df, x='FuelType')
plt.title('Distribution of Fuel Type')
plt.xlabel('Fuel Type')
plt.ylabel('Count')
plt.xticks(rotation=45)
plt.tight_layout()
plt.show()


# Distribution of Seats
plt.figure(figsize=(8, 6))
sns.countplot(data=df, x='Seats')
plt.title('Distribution of Seats')
plt.xlabel('Number of Seats')
plt.ylabel('Count')
plt.show()

# Distribution of BodyType
plt.figure(figsize=(12, 6))
sns.countplot(data=df, x='BodyType')
plt.title('Distribution of Body Type')
plt.xlabel('Body Type')
plt.ylabel('Count')
plt.xticks(rotation=45)
plt.tight_layout()
plt.show()


# Distribution of Brand (showing top 20 for clarity)
plt.figure(figsize=(14, 7))
sns.countplot(data=df, y='Brand', order=df['Brand'].value_counts().index[:20])
plt.title('Distribution of Top 20 Brands')
plt.xlabel('Count')
plt.ylabel('Brand')
plt.show()

print("Transmission Mapping:")
print(transmission_mapping)
print("\nFuel Type Mapping:")
print(fuel_type_mapping)


df['Price'] = pd.to_numeric(df['Price'], errors='coerce')
df['Price'] = df['Price'].fillna(0).astype(int)
print(df['Price'].dtype)
df.head()

df_filtered = df[(df['Price'] <= 200000) & (df['Kilometres'] <= 200000) & (df['Year'] >= 2000)].copy()

print("Shape of DataFrame before filtering:", df.shape)
print("Shape of DataFrame after filtering:", df_filtered.shape)
display(df_filtered.head())

brand_counts = df['Brand'].value_counts()
brands_to_keep = brand_counts[brand_counts >= 200].index
df_filtered_brands = df[df['Brand'].isin(brands_to_keep)].copy()

print("Shape of DataFrame before dropping brands:", df.shape)
print("Shape of DataFrame after dropping brands:", df_filtered_brands.shape)
display(df_filtered_brands.head())

# Calculate median price for each brand to order the plot
median_prices = df_filtered_brands.groupby('Brand')['Price'].median().sort_values(ascending=False).index[:20]

# Create a box plot of Price by Brand for the top 20 brands
plt.figure(figsize=(16, 8))
sns.boxplot(data=df_filtered_brands[df_filtered_brands['Brand'].isin(median_prices)],
            x='Price', y='Brand', order=median_prices)
plt.title('Price Range by Top 20 Brands (Ordered by Median Price)')
plt.xlabel('Price')
plt.ylabel('Brand')
plt.grid(axis='x', linestyle='--', alpha=0.7)
plt.tight_layout()
plt.show()


model_counts = df_filtered_brands.groupby(['Brand', 'Model']).size().reset_index(name='count')
qualified_models = model_counts[model_counts['count'] >= 50]

print("Number of unique Brand-Model combinations before filtering:", len(model_counts))
print("Number of unique Brand-Model combinations with at least 20 entries:", len(qualified_models))
display(qualified_models.head())

df_filtered_models = df_filtered_brands.merge(qualified_models[['Brand', 'Model']], on=['Brand', 'Model'], how='inner')

print("Shape of DataFrame before filtering models:", df_filtered_brands.shape)
print("Shape of DataFrame after filtering models:", df_filtered_models.shape)
display(df_filtered_models.head())


model_frequencies = df_filtered_models.groupby(['Brand', 'Model']).size().reset_index(name='frequency')
top_models_per_brand = model_frequencies.groupby('Brand').apply(lambda x: x.nlargest(3, 'frequency')).reset_index(drop=True)

df_top_models = df_filtered_models.merge(top_models_per_brand[['Brand', 'Model']], on=['Brand', 'Model'], how='inner')

print("Number of unique Brand-Model combinations after selecting top 3 per brand:", len(top_models_per_brand))
print("Shape of DataFrame after selecting top 3 models per brand:", df_top_models.shape)
display(df_top_models.head())

df_z=df_filtered_models.dropna()

df_z.info()

price_stats_by_model = df_z.groupby(['Brand', 'Model'])['Price'].agg(['count', 'min', 'median', 'mean', 'max']).reset_index()
print(price_stats_by_model)

price_stats_by_model['median_price_rank'] = price_stats_by_model.groupby('Brand')['median'].rank(method='dense', ascending=True).astype(int) - 1
price_stats_by_model_ranked = price_stats_by_model.sort_values(by=['Brand', 'median_price_rank'])
print(price_stats_by_model_ranked.head())


df_z = df_z.merge(price_stats_by_model_ranked[['Brand', 'Model', 'median_price_rank']], on=['Brand', 'Model'], how='left')
df_z.head()



# Filter the DataFrame for 'NEW' vehicles
df_new_cars = df_z[df_z['UsedOrNew'] == 'NEW'].copy()

# Calculate median price by brand for new cars to order the plot
median_prices_new = df_new_cars.groupby('Brand')['Price'].median().sort_values(ascending=False).index

# Create a box plot of Price by Brand for new cars
plt.figure(figsize=(16, 8))
sns.boxplot(data=df_new_cars, x='Price', y='Brand', order=median_prices_new)
plt.title('Price Range by Brand for NEW Vehicles (Ordered by Median Price)')
plt.xlabel('Price')
plt.ylabel('Brand')
plt.grid(axis='x', linestyle='--', alpha=0.7)
plt.tight_layout()
plt.show()


# Filter the DataFrame for 'NEW' and 'DEMO' vehicles with Kilometres < 5000
df_new_demo_cars = df_z[(df_z['UsedOrNew'].isin(['NEW', 'DEMO','USED'])) & (df_z['Kilometres'] < 5000)].copy()

# Calculate median price by brand for new and demo cars to order the plot
median_prices_new_demo = df_new_demo_cars.groupby('Brand')['Price'].median().sort_values(ascending=False).index

# Create a box plot of Price by Brand for new and demo cars
plt.figure(figsize=(16, 8))
sns.boxplot(data=df_new_demo_cars, x='Price', y='Brand', order=median_prices_new_demo,hue='UsedOrNew')
plt.title('Price Range by Brand for NEW and DEMO Vehicles (Kilometres < 5000, Ordered by Median Price)')
plt.xlabel('Price')
plt.ylabel('Brand')
plt.grid(axis='x', linestyle='--', alpha=0.7)
plt.tight_layout()
plt.show()



# Filter the DataFrame for 'NEW' and 'DEMO' vehicles
df_new_demo_cars = df_z[df_z['UsedOrNew'].isin(['NEW', 'DEMO'])].copy()

# Calculate median price by brand for new and demo cars to order the plot
median_prices_new_demo = df_new_demo_cars.groupby('Brand')['Price'].median().sort_values(ascending=False).index

# Create a box plot of Price by Brand for new and demo cars
plt.figure(figsize=(16, 8))
sns.boxplot(data=df_new_demo_cars, x='Price', y='Brand', order=median_prices_new_demo)
plt.title('Price Range by Brand for NEW and DEMO Vehicles (Ordered by Median Price)')
plt.xlabel('Price')
plt.ylabel('Brand')
plt.grid(axis='x', linestyle='--', alpha=0.7)
plt.tight_layout()
plt.show()


df_z['price_per_age'] = df_z['Price'] / (df_z['Age'] + 1)
df_z.head()


import matplotlib.pyplot as plt
import seaborn as sns

# Filter the DataFrame for Kilometres < 10000
df_filtered_kilometers = df_z[df_z['Kilometres'] < 5000].copy()

# Calculate median price_per_age by brand to order the plot for the filtered data
median_price_per_age_by_brand = df_filtered_kilometers.groupby('Brand')['price_per_age'].median().sort_values(ascending=False).index

# Create a box plot of price_per_age by Brand for the filtered data
plt.figure(figsize=(16, 8))
sns.boxplot(data=df_filtered_kilometers, x='price_per_age', y='Brand', order=median_price_per_age_by_brand)
plt.title('Distribution of Price Per Age by Brand (Kilometres < 10000, Ordered by Median Price Per Age)')
plt.xlabel('Price Per Age')
plt.ylabel('Brand')
plt.grid(axis='x', linestyle='--', alpha=0.7)
plt.tight_layout()
plt.show()


selected_brands = ['BMW', 'Toyota', 'MG']

for brand in selected_brands:
    brand_df = df_z[df_z['Brand'] == brand].copy()
    
    if not brand_df.empty:
        plt.figure(figsize=(12, 8))
        sns.scatterplot(data=brand_df, x='Kilometres', y='Price', hue='Model', palette='tab10', s=100)
        plt.title(f'Price vs. Kilometres for {brand} Models')
        plt.xlabel('Kilometres')
        plt.ylabel('Price')
        plt.grid(True)
        plt.legend(title='Model', bbox_to_anchor=(1.05, 1), loc='upper left')
        plt.tight_layout()
        plt.show()
    else:
        print(f"No data available for brand: {brand}")


# Step 1: near-new cars
near_new = df_z[df_z["Kilometres"] <= 10000]

# Step 2: estimate new price
new_price = (
    near_new
    .groupby(["Brand", "Model"])["Price"]
    .quantile(0.95)
    .reset_index()
    .rename(columns={"Price": "New_Price"})
)

# Step 3: merge back
df_z = df_z.merge(new_price, on=["Brand", "Model"], how="left")

# Step 4: retention ratio
df_z["retention"] = df_z["Price"] / df_z["New_Price"]


import matplotlib.pyplot as plt
import seaborn as sns

plt.figure(figsize=(12, 7))
sns.scatterplot(data=df_z, x='Kilometres', y='retention', alpha=0.6, hue='Brand', palette='tab10', legend='full')
plt.title('Retention vs. Kilometres')
plt.xlabel('Kilometres')
plt.ylabel('Retention (Price / New_Price)')
plt.grid(True)
plt.legend(bbox_to_anchor=(1.05, 1), loc='upper left')
plt.tight_layout()
plt.show()


import matplotlib.pyplot as plt
import seaborn as sns

selected_brands = ['Toyota', 'BMW', 'MG']
df_selected_brands = df_z[df_z['Brand'].isin(selected_brands)].copy()

plt.figure(figsize=(14, 8))
sns.lmplot(data=df_selected_brands, x='Kilometres', y='retention', hue='Brand', lowess=True, aspect=1.5, height=6)
plt.title('Smoothed Retention vs. Kilometres (LOWESS) for Selected Brands')
plt.xlabel('Kilometres')
plt.ylabel('Retention (Price / New_Price)')
plt.grid(True)
plt.tight_layout()
plt.show()


import matplotlib.pyplot as plt
import seaborn as sns

# Filter the DataFrame for Kilometres < 10000
df_filtered_kilometers = df_z[df_z['Kilometres'] < 5000].copy()

# Calculate median price_per_age by brand to order the plot for the filtered data
max_price_by_brand = df_filtered_kilometers.groupby('Brand')['Price'].max().sort_values(ascending=False).index

# Create a box plot of price_per_age by Brand for the filtered data
plt.figure(figsize=(16, 8))
sns.boxplot(data=df_filtered_kilometers, x='price_per_age', y='Brand', order=max_price_by_brand)
plt.title('Distribution of Price by Brand (Kilometres < 10000, Ordered by Median Price Per Age)')
plt.xlabel('Price')
plt.ylabel('Brand')
plt.grid(axis='x', linestyle='--', alpha=0.7)
plt.tight_layout()
plt.show()


import matplotlib.pyplot as plt
import seaborn as sns

# Filter the DataFrame for Kilometres < 10000
df_filtered_kilometers = df_z[df_z['Kilometres'] < 5000].copy()

# Calculate median price_per_age by brand to order the plot for the filtered data
min_price_by_brand = df_filtered_kilometers.groupby('Brand')['Price'].min().sort_values(ascending=False).index

# Create a box plot of price_per_age by Brand for the filtered data
plt.figure(figsize=(16, 8))
sns.boxplot(data=df_filtered_kilometers, x='price_per_age', y='Brand', order=min_price_by_brand)
plt.title('Distribution of Price by Brand (Kilometres < 10000, Ordered by Median Price Per Age)')
plt.xlabel('Price')
plt.ylabel('Brand')
plt.grid(axis='x', linestyle='--', alpha=0.7)
plt.tight_layout()
plt.show()


import numpy as np
import pandas as pd
from sklearn.model_selection import GroupKFold
from sklearn.metrics import mean_absolute_percentage_error
from sklearn.compose import ColumnTransformer
from sklearn.pipeline import Pipeline
from sklearn.preprocessing import OneHotEncoder
from lightgbm import LGBMRegressor

df = df_z.copy()

# ---------- A) Build New_Price proxy (Brand x Model) ----------
near_new = df[df["Kilometres"] <= 10000].copy()

new_price = (near_new
    .groupby(["Brand","Model"])["Price"]
    .quantile(0.95)
    .rename("New_Price_bm")
    .reset_index()
)

df = df.merge(new_price, on=["Brand","Model"], how="left")

# Fallback: Brand-level proxy if Brand-Model missing
brand_new = (near_new
    .groupby("Brand")["Price"]
    .quantile(0.95)
    .rename("New_Price_b")
    .reset_index()
)

df = df.merge(brand_new, on="Brand", how="left")

df["New_Price"] = df["New_Price_bm"].fillna(df["New_Price_b"])
df = df[df["New_Price"].notna()].copy()

# ---------- B) Retention target ----------
df["retention"] = df["Price"] / df["New_Price"]
df["retention"] = df["retention"].clip(lower=0.02, upper=1.30)  # control noise/outliers
df["y"] = np.log(df["retention"])  # log-retention target

# ---------- C) Non-linear km feature ----------
df["log_km"] = np.log1p(df["Kilometres"])

# ---------- D) Features ----------
num_cols = ["Age","log_km","FuelConsumption","CylindersinEngine","Seats","age_kilometer_interaction"]
cat_cols = ["Brand","Model","UsedOrNew","DriveType","BodyType","Transmission","FuelType"]

X = df[num_cols + cat_cols]
y = df["y"]

# Group split to avoid leakage (same Brand-Model in train & test)
groups = df["Brand"].astype(str) + "||" + df["Model"].astype(str)

pre = ColumnTransformer(
    transformers=[
        ("cat", OneHotEncoder(handle_unknown="ignore"), cat_cols),
        ("num", "passthrough", num_cols),
    ],
    remainder="drop"
)

model = LGBMRegressor(
    n_estimators=1500,
    learning_rate=0.03,
    num_leaves=63,
    min_child_samples=50,
    subsample=0.8,
    colsample_bytree=0.8,
    random_state=42
)

pipe = Pipeline([("pre", pre), ("model", model)])

# ---------- E) CV evaluate ----------
gkf = GroupKFold(n_splits=5)
mape_scores = []
for tr, te in gkf.split(X, y, groups):
    pipe.fit(X.iloc[tr], y.iloc[tr])
    pred_log_ret = pipe.predict(X.iloc[te])

    # convert back to retention then to price
    pred_ret = np.exp(pred_log_ret)
    pred_price = pred_ret * df.iloc[te]["New_Price"].values

    mape = mean_absolute_percentage_error(df.iloc[te]["Price"].values, pred_price)
    mape_scores.append(mape)

print("CV MAPE (price):", np.mean(mape_scores))

# Fit final model on all data
pipe.fit(X, y)



import numpy as np
import pandas as pd

def brand_retention_curve(pipe, df, brand, kms_grid):
    # Use typical/median values so curve reflects brand×km effect
    row = df[df["Brand"] == brand].copy()
    base = {}
    base["Brand"] = brand
    base["Model"] = row["Model"].mode().iat[0]              # typical model
    base["UsedOrNew"] = row["UsedOrNew"].mode().iat[0]
    base["DriveType"] = row["DriveType"].mode().iat[0]
    base["BodyType"] = row["BodyType"].mode().iat[0]
    base["Transmission"] = row["Transmission"].mode().iat[0]
    base["FuelType"] = row["FuelType"].mode().iat[0]
    base["Age"] = row["Age"].median()
    base["FuelConsumption"] = row["FuelConsumption"].median()
    base["CylindersinEngine"] = row["CylindersinEngine"].median()
    base["Seats"] = row["Seats"].median()

    out = []
    for km in kms_grid:
        tmp = base.copy()
        tmp["log_km"] = np.log1p(km)
        tmp["age_kilometer_interaction"] = tmp["Age"] * (km/100_000)  # keep same scaling you used
        Xtmp = pd.DataFrame([tmp])
        log_ret = pipe.predict(Xtmp)[0]
        out.append((km, float(np.exp(log_ret))))
    return pd.DataFrame(out, columns=["Kilometres","Pred_Retention"])

kms_grid = np.linspace(0, 500_000, 40)

curves = []
for b in ["Toyota","BMW","MG","Land"]:
    curves.append(brand_retention_curve(pipe, df, b, kms_grid).assign(Brand=b))
curves = pd.concat(curves, ignore_index=True)

# Then plot curves: Kilometres vs Pred_Retention by Brand


import matplotlib.pyplot as plt

# curves dataframe expected columns:
# ["Kilometres", "Pred_Retention", "Brand"]

plt.figure(figsize=(10, 6))

for brand in curves["Brand"].unique():
    tmp = curves[curves["Brand"] == brand].sort_values("Kilometres")
    plt.plot(tmp["Kilometres"], tmp["Pred_Retention"], marker="o", label=brand)

plt.title("Predicted Retention vs Kilometres (Brand Curves)")
plt.xlabel("Kilometres")
plt.ylabel("Predicted Retention (Price / New_Price)")
plt.grid(True, alpha=0.3)
plt.legend(title="Brand")
plt.show()


import pickle


# Save trained pipeline
with open("final_price_pipe.pkl", "wb") as f:
    pickle.dump(pipe, f)

# Save columns expected by the pipeline
with open("model_features.pkl", "wb") as f:
    pickle.dump(list(X.columns), f)

print("✅ Saved: final_price_pipe.pkl + model_features.pkl")
